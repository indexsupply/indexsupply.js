// generated by: scripts/replace-version.js
const userAgentVersion = "2.0.3";

export type Hex = `0x${string}`;

export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3,
}

class Logger {
  public level: LogLevel;
  constructor() {
    this.level = LogLevel.INFO;
  }
  log(level: LogLevel, message: string, ...args: unknown[]) {
    if (level <= this.level) {
      console.log(`[${LogLevel[level]}] ${message}`, ...args);
    }
  }
};

let defaultLogger = new Logger();
let logger: LogHandler = (level, message, ...args) => {
  defaultLogger.log(level, message, ...args);
};

const logError = (message: string, ...args: unknown[]) => {
  logger(LogLevel.ERROR, message, ...args);
}

const logDebug = (message: string, ...args: unknown[]) => {
  logger(LogLevel.DEBUG, message, ...args);
}

export const setLogLevel = (level: LogLevel): void => {
  defaultLogger.level = level;
};

export type LogHandler = (level: LogLevel, message: string, ...args: unknown[]) => void;
export const setLogger = (handler: LogHandler): void => {
  logger = handler;
};

class EUser extends Error { constructor(s: string) { super(s); } }
class EWait extends Error { constructor(s: string) { super(s); } }
class ERetry extends Error { constructor(s: string) { super(s); } }

class ErrorHandler {
  public last: Error;
  constructor() { this.last = new Error(); }

  async error(msg: string, error: any) {
    if (error instanceof Error) this.last = error;
    if (error instanceof EWait) {
      logError(`server error. will wait before retry: ${msg} ${error}`);
      await new Promise(resolve => setTimeout(resolve, 1000 + Math.floor(Math.random() * 2000)));
    } else if (error instanceof ERetry) {
      logError(`server error. will retry now: ${msg} ${error}`);
    } else if (error instanceof EUser) {
      logError(`user error. will not retry: ${msg} ${error}`);
      throw error;
    } else {
      logError(`${msg} ${error}`);
    }
  }
}

export type JsonValue = ReturnType<typeof JSON.parse>;
export type Formatter<T> = (row: JsonValue[]) => T;
type DefaultType = { [key: string]: JsonValue };

// Alias fetch's request and response
// so that we can use the words: Request, Response
const FetchRequest = Request;
type FetchRequest = globalThis.Request;
type FetchResponse = globalThis.Response;

/**
* A mapping of: chain-id to block-number
* When a cursor is returned from a request the block number
* is the latest block indexed by the API.
* When a cursor is sent to the server it requests data past the block number.
* @see {@link https://www.indexsupply.net/docs#cursor Cursor Docs}
*/
export class Cursor extends Map<bigint, bigint> {
  toString(): string {
    return [...this.entries()]
      .flatMap(([k, v]) => [k.toString(), v.toString()])
      .join("-");
  }

  static fromString(s: string): Cursor {
    const parts = s.split("-");
    if (parts.length % 2 !== 0) throw new Error("Invalid cursor string");
    const c = new Cursor();
    for (let i = 0; i < parts.length; i += 2) {
      c.set(BigInt(parts[i]), BigInt(parts[i + 1]));
    }
    return c;
  }
}


/**
 * Represents a request to the API
 * @template T The expected return type of the formatted data
 * @see {@link https://www.indexsupply.net/docs#get-query GET /query API documentation}
 * @see {@link https://www.indexsupply.net/docs#chains Supported chains}
 * @see {@link https://www.indexsupply.net/docs#sql SQL query syntax}
 * @example
 * interface Transfer { from: string; to: string; value: string }
 *
 * const request: Request<Transfer> = {
 *   chainId: 1n,
 *   query: 'SELECT "from", "to", value FROM transfer',
 *   signatures: ["Transfer(address indexed from, address indexed to, uint256 value)"],
 *   formatRow: (row) => ({
 *     from: row[0] as string,
 *     to: row[1] as string,
 *     value: row[2] as string
 *   })
 * }
 */
type BaseRequest<T> = {
  /** Optional AbortSignal. Use this to cancel the request. */
  abortSignal?: AbortSignal;
  /** Optional number of attempts to retry the request. */
  retryAttempts?: number;
  /** Optional custom API URL. Defaults to https://api.indexsupply.net */
  apiUrl?: string;
  /** Optional API key for authentication. Unauthenticated requests limited to 5 per minute */
  apiKey?: string;
  /** @deprecated use `signatures` */
  eventSignatures?: ReadonlyArray<string>;
  /** Optional array of signatures to filter transactions and events */
  signatures?: ReadonlyArray<string>;
  /** SQL query to execute */
  query: string;
  /** Optional function to format the row data. Required if T is not DefaultType */
  formatRow?: T extends DefaultType ? undefined | Formatter<T> : Formatter<T>;
};

type RequestWithCursor<T> = BaseRequest<T> & {
  cursor: Cursor;
  chainId?: never;
};

type RequestWithChainId<T> = BaseRequest<T> & {
  chainId: bigint;
  cursor?: never;
};

export type Request<T> = RequestWithCursor<T> | RequestWithChainId<T>;

function apiUrl<T>(request: Request<T>, path: string): string {
  let base = "https://api.indexsupply.net/v2";
  if (request.apiUrl) {
    base = request.apiUrl;
  }
  return `${base}/${path}`;
}

function queryParams<T>(request: Request<T>, startBlock: bigint): URLSearchParams {
  const params = new URLSearchParams();
  if (request.apiKey) {
    params.set("api-key", request.apiKey.toString());
  }
  if (request.chainId) {
    params.set("cursor", [request.chainId, startBlock.toString()].join("-"));
  }
  if (request.cursor) {
    params.set("cursor", request.cursor.toString());
  }
  request.eventSignatures?.forEach((sig) => {
    params.append("signatures", sig);
  });
  request.signatures?.forEach((sig) => {
    params.append("signatures", sig);
  });
  params.set("query", request.query);
  return params;
}

function jsonBody<T>(request: Request<T>): string {
  const body: any = {};
  if (request.chainId) {
    body["cursor"] = [request.chainId, "0"].join("-");
  }
  if (request.cursor) {
    body["cursor"] = request.cursor.toString();
  }
  body["signatures"] = [];
  body["signatures"].push(...request.eventSignatures ?? []);
  body["signatures"].push(...request.signatures ?? []);
  body["query"] = request.query;
  return JSON.stringify([body]);
}

type Column = {
  name: string;
  pgtype: string;
}

/**
 * Represents the response structure from the API
 * @template T The type of the result items
 * @see {@link https://www.indexsupply.net/docs#response Response format documentation}
 * @example
 * type ExampleResponse = Response<{ address: string, value: string }> = {
 *   "cursor": "8453-18479546",
 *   "columns": [
 *     {"name": "from",   "pgtype": "bytea"},
 *     {"name": "to",     "pgtype": "bytea"},
 *     {"name": "tokens", "pgtype": "numeric"}
 *   ],
 *   "rows":[[
 *         "0x0000000000000000000000000000000000000000",
 *         "0xdaabdaac8073a7dabdc96f6909e8476ab4001b34",
 *         "0"
 *   ]]
 * }
 */
export type Response<T> = {
  cursor: Cursor;
  columns: Array<Column>;
  rows: T[];
};

/**
 * Creates a default row formatter that maps column names to values
 * @param names - Array of column names
 * @returns A formatter function that creates an object with column name keys
 */
const defaultFormatRow = (names: string[]): Formatter<DefaultType> => {
  return (row: JsonValue[]) => {
    if (row.length !== names.length) {
      throw new Error(
        `Row length (${row.length}) does not match column names length (${names.length})`,
      );
    }
    return names.reduce((acc, name, index) => {
      acc[name] = row[index];
      return acc;
    }, {} as DefaultType);
  };
};

function parseResponse<T>(
  parsed: any,
  formatRow?: Formatter<T>
): Array<Response<T>> {
  return (parsed as any[]).map(({ cursor, columns, rows }) => {
    return {
      cursor: Cursor.fromString(cursor),
      columns,
      rows: rows.map(formatRow ?? defaultFormatRow(columns.map((c: Column) => c.name))),
    };
  });
}

async function checkResponseError<T>(response: FetchResponse) {
  logDebug(`received ${response.status} response. content-length: ${response.headers.get("content-length")}`);
  if ((BigInt(response.status) / 100n) === 2n) {
    return;
  }

  let errorMessage = await response.text();
  errorMessage = JSON.parse(errorMessage)?.message ?? errorMessage;

  if (response.status === 408) {
    throw new ERetry(errorMessage);
  } else if (response.status === 429) {
    throw new EWait(errorMessage);
  } else if (response.status === 404) {
    throw new EUser("not found");
  } else if ((BigInt(response.status) / 100n) === 4n) {
    throw new EUser(errorMessage);
  } else {
    throw new EWait(`${response.status} ${errorMessage}`);
  }
}

/**
 * Executes a query against the API and returns formatted results
 * @template T The type of the formatted results
 * @param request - The request data
 * @returns Promise containing the block number and formatted results
 * @throws Error if the API response is invalid or unexpected
 * @see {@link https://www.indexsupply.net/docs#get-query GET /query API documentation}
 * @see {@link https://www.indexsupply.net/docs#queries Query types}
 * @example
 * // Basic usage with default formatting
 * const result = await query({
 *   chainId: 1n,
 *   query: 'SELECT "from", "to", value FROM transfer LIMIT 1',
 *   signatures: ["Transfer(address indexed from, address indexed to, uint256 value)"]
 * });
 *
 * // With custom type and formatting
 * interface Transfer { from: string; to: string; value: string }
 * const transfers = await query<Transfer>({
 *   chainId: 1n,
 *   query: 'SELECT "from", "to", value FROM transfer LIMIT 1',
 *   signatures: ["Transfer(address indexed from, address indexed to, uint256 value)"],
 *   formatRow: (row) => ({
 *     from: row[0] as string,
 *     to: row[1] as string,
 *     value: row[2] as string
 *   })
 * });
 */
export async function query<T = DefaultType>(userRequest: Request<T>): Promise<Response<T>> {
  const handle = new ErrorHandler();
  for (let attempt = 0; attempt < (userRequest.retryAttempts ?? 5); attempt++) {
    try {
      let url = apiUrl(userRequest, "query");
      let body = jsonBody(userRequest);
      logDebug(`POST ${url} ${body}`);
      let response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "User-Agent": `indexsupply.js/${userAgentVersion}`,
          ...(userRequest.apiKey && { "Api-Key": userRequest.apiKey }),
        },
        body,
      });
      await checkResponseError(response);
      return parseResponse(await response.json(), userRequest.formatRow)[0];
    } catch (e) {
      await handle.error("query", e);
    }
  }
  throw handle.last;
}

export type Stream = ReadableStreamDefaultReader<Uint8Array>;

export async function* readStream(reader: Stream): AsyncGenerator<JsonValue> {
  const decoder = new TextDecoder("utf-8");
  let buffer = new String();
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      const decoded = decoder.decode(value, { stream: true });
      logDebug(`read ${decoded}`);
      buffer += decoded;

      let idx;
      while ((idx = buffer.indexOf("\n\n")) !== -1) {
        const block = buffer.slice(0, idx);
        buffer = buffer.slice(idx + 2);

        const lines = block.split("\n");
        for (const line of lines) {
          if (line.startsWith("data:")) {
            const jsonString = line.slice(5).trim();
            try {
              yield JSON.parse(jsonString);
            } catch {
              await reader.cancel("Invalid JSON in data line");
              throw new Error("Failed to parse JSON");
            }
          }
        }
      }
    }
  } finally {
    await reader.cancel("Stream closed");
  }
}

/**
* `queryLive` will call `startBlock` each time a new Live Query connection to
the server is established. If the connection is restarted
then `queryLive` will automatically restablish the connection
and will call `startBlock` again to ensure we resume at the correct block height.
*/
export type startBlock = () => Promise<bigint>;

/**
 * Creates a live query connection that yields results as the API indexes new blocks
 * @template T The type of the formatted results
 * @param userRequest - The request configuration with optional starting block number
 * @param userRequest.startBlock - When provided, this function will be
 used as the starting block height for the query. It is common to save the
 latest block processed in a database (using your database's transaction system)
 * @yields Response objects containing block numbers and formatted results
 * @throws Error if the API response is invalid or unexpected
 * @see {@link https://www.indexsupply.net/docs#get-query-live GET /query-live API documentation}
 * @see {@link https://www.indexsupply.net/docs#reorgs Chain reorganization handling}
 * @example
 * // Basic usage with default formatting
 * for await (const response of queryLive({
 *   chainId: 1n,
 *   startBlock: async () => (latest + 1n),
 *   query: 'SELECT "from", "to", value FROM transfer',
 *   signatures: ["Transfer(address indexed from, address indexed to, uint256 value)"],
 * })) {
 *   console.log(response.cursor, response.rows);
 * }
 *
 * // With custom type and formatting
 * interface Transfer { from: string; to: string; value: string }
 * for await (const response of queryLive<Transfer>({
 *   chainId: 1n,
 *   query: 'SELECT "from", "to", value FROM transfer',
 *   signatures: ["Transfer(address indexed from, address indexed to, uint256 value)"],
 *   formatRow: (row) => ({
 *     from: row[0] as string,
 *     to: row[1] as string,
 *     value: row[2] as string
 *   })
 * })) {
 *   console.log(response.blockNumber, response.result);
 * }
 */
export async function* queryLive<T = DefaultType>(
  userRequest: Request<T> & {
    startBlock?: startBlock;
  },
): AsyncGenerator<Response<T>, void, unknown> {
  let userRequestedAbort = false;
  userRequest.abortSignal?.addEventListener("abort", () => {
    logDebug("live query aborted")
    userRequestedAbort = true;
  });
  const handle = new ErrorHandler();
  for (let attempt = 0; attempt < (userRequest.retryAttempts ?? 50); attempt++) {
    try {
      let start = 0n;
      if (userRequest.startBlock) {
        logDebug("startBlock called");
        start = await userRequest.startBlock();
        logDebug(`startBlock returned ${start}`);
      }
      let url = apiUrl(userRequest, "query-live");
      let params = queryParams(userRequest, start);
      let completeUrl = `${url}?${params}`;
      logDebug(`GET ${completeUrl}`);

      let response = await fetch(completeUrl, {
        signal: userRequest.abortSignal,
        headers: { "User-Agent": `indexsupply.js/${userAgentVersion}` }
      });
      await checkResponseError(response);
      const reader = response.body!.getReader() as Stream;
      for await (const parsed of readStream(reader)) {
        if (parsed.error === "user") {
          throw new EUser(parsed.message);
        } else if (parsed.error === "server") {
          throw new EWait(parsed.error.server);
        } else {
          yield parseResponse(parsed, userRequest.formatRow)[0];
          attempt = 0;
        }
      }
    } catch (e) {
      if (userRequestedAbort) return;
      await handle.error("query-live", e);
    }
  }
  throw handle.last;
}
